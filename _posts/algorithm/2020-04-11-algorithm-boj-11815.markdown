---
layout: post
title:  "백준 알고리즘 풀이 - 11815번(짝수? 홀수?)"
date:   2020-04-11 23:00:00 +0900
categories: python algorithm
---

[문제](https://www.acmicpc.net/problem/11815) |
**[✏️정답 확인](https://github.com/live2skull/TheLordOfAlgorithm/blob/master/problems_boj/%EA%B8%B0%ED%83%80/11815.py)**

주어진 수 N의 약수를 구해 갯수가 짝수이면 1, 홀수이면 0을 출력한다.

N의 약수의 갯수는 소인수 분해하여 다음과 같이 구할 수 있다.
```
(X차수 + 1) * (Y차수 + 1) * ...
```

하지만 이 문제에서 살펴볼 점은 N의 범위가 1부터 10의 18승까지 그 범위가 매우 크므로 소인수 분해하면 주어진 시간에 문제를 풀 수 없다. 따라서 문제의 유형과 약수의 갯수 성질을 적절히 활용한다.

**\#1. 두 수의 곱이 홀수가 되려면 홀수 x 홀수인 경우만 존재한다.**  
**\#2. N의 약수 갯수의 짝수, 홀수 여부만 판단한다.**

모든 소인수의 갯수 + 1이 홀수이면 각 갯수가 짝수이므로, N이 **제곱수이면 약수의 갯수가 홀수**, 그렇지 않으면 약수의 갯수가 짝수임을 알 수 있다.

따라서 다음과 같이 풀 수 있다.
```
tg = int_input()
for q in ints_input(): print(1 if q == int(q ** 0.5) ** 2 else 0, end=' ') # 주의사항 참고
```

⚠️ 주의사항 - 파이썬 `float` 자료형의 정확도  
파이썬은 기본 사칙연산 결과 및 실수의 자료형으로 `float`을 사용하는데, 정확도에 오류가 있어 정밀한 연산에 문제가 있다.
```
>>> 1.1 * 1.1
1.2100000000000002
>>> type(1.1 * 1.1)
<class 'float'>
```

문제 풀이 중 계속 오답의 원인을 찾지 못하다 N의 루트 계산을 `int`형으로 변환한 풀이를 보고 반례를 직접 찾아 보았다.
```
def main():
    r1 = list()
    for q in range(1000000000000000000, 1000000000001000000):
        r1.append(1 if q == int(q ** 0.5) ** 2 else 0)


    r2 = list()
    for q in range(1000000000000000000, 1000000000001000000):
        r2.append(1 if q == (q ** 0.5) ** 2 else 0)

    for idx in range(0, len(r1)):
        if r1[idx] != r2[idx]: print(idx)

if __name__ == '__main__':
    main()

# 256 512 768 896 ...
```

파이썬의 루트 계산(math.sqrt 또는 ** 0.5) 은 `float` 값을 반환하는데, 이로 인해 매우 큰 수의 연산에서 값 비교 문제가 있었다.
```
>>> q = 1000000000000000256
>>> (q ** 0.5) ** 2
1.0000000000000003e+18
>>> (q ** 0.5) ** 2 == q
True ## ?????
>>> 1.0000000000000003e+18 == 1000000000000000256
True ## ...
```

즉 매우 큰 수에서 소숫점 값으로 인해 문제가 발생했던 것이다. 따라서 제곱수의 루트 값은 정수이므로, `int()` 변환으로 소숫점을 버려도 값이 동일한 성질을 이용한다. 이렇게 변환하면 제곱수의 `int(q ** 0.5) ** 2` 깂은 동일한 q값이 구해지며, 그렇지 않은 값은 소숫점이 버려지게 되므로 다시 제곱해도 q값이 나오지 않는다.
