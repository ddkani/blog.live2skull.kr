---
layout: post
title:  "백준 알고리즘 풀이 - 7568번(덩치)"
date:   2020-04-09 23:20:00 +0900
categories: python pip algorithm
---

[문제](https://www.acmicpc.net/problem/7568) |
**[✏️정답 확인](https://github.com/live2skull/TheLordOfAlgorithm/blob/master/problems_boj/%EB%B8%8C%EB%A3%A8%ED%8A%B8_%ED%8F%AC%EC%8A%A4/7568.py)**

N명의 키와 몸무게가 주어지고, 각 사람들끼리 덩치 등수(우위)를 판별하는 문제이다.
일반적인 우위 판별의 경우, 한개의 객체가 나머지 객체 N-1과 모두 우위 판별이 가능하다면 파이썬 기준으로 `arr.sort(key=lambda x: ...)`와 같이 정렬하여 전체 등수를 판별할 수 있다.

하지만 문제의 다음 조건으로 인해, 특정 객체는 서로 우위 판별을 할 수 없다.
> 각자의 몸무게와 키의 대소관계가 서로 다른 경우, 각자는 누구도 상대방보다 더 크다고 할 수 없다.

따라서 각자 객체를 N-1개의 다른 객체와 모두 비교하여 덩치가 더 큰 횟수를 세어 우위를 판별해야 하므로, `조합`으로 모든 조합 가능한 경우의 수에 대해 덩치가 더 큰 횟수를 계산한다.

💡 순위를 정할 때 반드시 상대방보다 큰 횟수가 아닌, 상대방보다 작은 횟수로 판단하여도 된다.  
본 문제는 우위를 확인하고, 동점자가 있다면 순위를 동일하게 처리한 뒤 다음 순위를 뒤로 미룬다. 이 때 상대방보다 작은 횟수로 판단하면 동점자 순위조정을 추가로 하지 않아도 된다.

📝 테스트 코드 - 우위(순위) 판단하기
```
def main():
    tg = 9

    dt = [7,7,3,6,5,4,1,8,9]
    sc = [1] * 9 # 0부터 시작한다면 1순위 : 0부터 시작한다.

    for i in range(0, tg):
        v1 = dt[i]
        for j in range(i + 1, tg):
            v2 = dt[j]

            # j in range(1 + 1, tg) 이므로 순열이 아닌 조합의 수
            # 따라서 다시 반복되지 않으므로 두 수 각각의 대소비교를 한다.
            if v1 < v2: sc[i] += 1
            elif v1 > v2: sc[j] += 1

    print(sc, end=" ")

if __name__ == '__main__':
    main()
    # [3, 3, 8, 5, 6, 7, 9, 2, 1]
```
