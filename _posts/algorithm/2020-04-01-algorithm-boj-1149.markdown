---
layout: post
title:  "백준 알고리즘 풀이 - 1149번(RGB거리)"
date:   2099-04-04 00:00:00 +0000
categories: python pip algorithm
---

[문제](https://www.acmicpc.net/problem/1149) |
**[✏️정답 확인]()**

N값이 N-X에 의해 결정되므로(칠하는 전체 비용) 다이나믹 프로그래밍으로 구현한다.



단순히 매 N번째의 집에 가장 적은 가격의 페인트를 칠하면 안된다. 다음 N+1번째의 집에 칠할 수 있는 페인트가 이전 N번째에 의해 결정되기 때문이다.
>  1번 집의 색은 2번 집의 색과 같지 않아야 한다.  
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.  
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

따라서 매번 R, G, B를 선택하였을 때의 비용을 모두 저장하고, 다음 N+1에서는 이전 선택지에 의해 사용할 수 없는 선택(N에서 R이면 N+1에서 R 불가능)을 제외하고, 선택 가능한 경우에서 가장 최소 비용의 선택지를 저장한다.

```
def main():

    cnt = int_input()
    cost = []
    dp = []
    for i in range(0, cnt):
        cost.append(list(ints_input()))
        dp.append([0,0,0])

    dp[0][0] = cost[0][0]
    dp[0][1] = cost[0][1]
    dp[0][2] = cost[0][2]

    dp[1][0] = cost[1][0] + min(dp[0][1], dp[0][2])
    dp[1][1] = cost[1][1] + min(dp[0][0], dp[0][2])
    dp[1][2] = cost[1][2] + min(dp[0][0], dp[0][1])

    for i in range(2, cnt):
        # 문제에서는 i번째의 선택이 i-1, i+1과 달라야 한다고 했지만,
        # dp 작성시에 오름차순으로 작성하므로 i+1에 대한 판단을 하지 않아도 된다.
        dp[i][0] = cost[i][0] + min(dp[i-1][1], dp[i-1][2])
        dp[i][1] = cost[i][1] + min(dp[i - 1][0], dp[i - 1][2])
        dp[i][2] = cost[i][2] + min(dp[i - 1][0], dp[i - 1][1])

    print(min(dp[cnt-1][0], dp[cnt-1][1], dp[cnt-1][2]))
```
