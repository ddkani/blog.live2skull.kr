---
layout: post
title:  "윤영체제 - virtual memory address translation"
date:   2020-05-21 13:30:00 +0900
categories: os
---


### MMU (Memory Management Unit)  
가상 메모리와 물리 메모리 주소를 변환하는 하드웨어 장치.

### Translation table
가상 메모리 주소 (virtual memory address) 와 물리 메모리 주소(physical memory address)의 변환을 위한 맵핑 테이블로써, 운영체제가 관리한다.

프로세스별로 서로 분리된 가상 메모리 공간을 가지며, 따라서 각 프로세스별로 서로 다른 `translation table`을 갖는다.

----

## 페이징 개념

먼서, `page`, `page frame`는 다음과 같습니다. 각각 가상(논리), 물리 메모리로 서로 다릅니다.

|이름|설명|
|---|------|
page|가상 메모리를 특정 단위로 쪼갠 영역
page frame|물리 메모리를 특정 단위로 쪼갠 영역

CPU에는 `translation table`을 가리키는 `TTBA` 레지스터가 존재합니다. (translation table base register)


## 구현 가능한 방법

### 1. 맵핑 테이블 없이 가상 메모리 주소로 물리 메모리를 계산하여 접근

각 페이지의 크기를 4kbytes 로 가정합니다.

가상 메모리 주소 0x0001AFC 가 주어진다면, 4kb에 해당하는 구간을 제외한 0x00000AFC 는 페이지 내부에서의 오프셋, 0x0001 은 페이지의 번호가 됩니다. 

따라서, 물리 메모리의 주소를 다음 공식으로 계산할 수 있습니다.

```
물리 메모리 주소 = 시작 물리 메모리 주소(TTBA - PA base address) + 페이지 오프셋의 쉬프트 연산 + 페이지 내부 오프셋
```

하드웨어 특성에 의해, 위 예제인 32비트 시스템에서 가상 메모리의 상위 24비트를 초기화하면 오프셋을, 우측으로 3비트 쉬프트 연산하면 가상 페에지의 번호를 구할 수 있습니다.

**단점**
모든 페이지 프레임은 위 계산 방법에 의해 연속되게 구성되어야 합니다. 따라서 가상 메모리 크기에 일치하는 물리 메모리 영역을 모두 가지고 있지 않다면, 특정 구간에서 가상 메모리의 맵핑이 더 이상 불가능하게 됩니다.


### 2. 패이지와 페이지 프레임을 각각 맵핑

1번 예제와 동일히 각 페이지의 크기를 4kbytes로 가정합니다.

가상 메모리의 페이지는 각각의 물리 메모리 페이지에 맵핑되는 `translation table`을 사용합니다.

**장점**
프로세스의 메모리 수요에 따라 페이지를 할당 및 해제할 수 있습니다. 프로세스에서 페이지가 추가로 필요하다면, 운영체제에서 사용할 수 있는 특정 페이지 영역을 할당받고, 필요 없다면 반납하여 메모리를 효율적으로 사용하게 됩니다.

**단점**
사용하는 페이지가 많아지거나, 64비트 시스템과 같이 메모리의 크기가 커지면 `translation table`이 필요로 하는 메모리 영역도 커지게 됩니다.